package parserlexer;
import java_cup.runtime.*;

/*
 * Especificación CUP para la definición de terminales (tokens)
 * Objetivo: Generar la clase 'sym.java' que contiene las constantes numéricas para cada tipo de token.
 *           Aunque CUP es un generador de parsers, en esta etapa (Lexer) lo usamos solo para definir el vocabulario.
 * Entrada: Lista de terminales.
 * Salida: Archivo sym.java (y Parser.java esqueleto).
 */

parser code {:
    public static Nodo arbolSintactico = null;  // Almacena el árbol

    // Sobrescribir método de reporte de errores
        public void report_error(String message, Object info) {
            StringBuilder m = new StringBuilder("Error sintáctico");

            if (info instanceof Symbol) {
                Symbol s = (Symbol) info;
                if (s.left >= 0) {
                    m.append(" en línea " + (s.left + 1));
                    if (s.right >= 0) {
                        m.append(", columna " + (s.right + 1));
                    }
                }
            }

            m.append(": " + message);
            System.err.println(m);
        }

        // Error fatal
        public void report_fatal_error(String message, Object info) {
            report_error(message, info);
            System.err.println("No se puede continuar el análisis.");
            System.exit(1);
        }
:}

/* Inicialización del scanner */
init with {: /* No initialization needed */ :};

/* 
 * ----- Definición de Terminales -----
 * Estos son los nombres que usa Lexer.jflex en los 'return symbol(sym.NOMBRE)'
 */

/* Palabras reservadas */
terminal WORLD, LOCAL, INT, FLOAT, BOOL, CHAR, STRING;
terminal NAVIDAD, COAL, GIFT;
terminal DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN, FOR;
terminal RETURN, BREAK, SHOW, GET, ENDL;
terminal TRUE, FALSE;

/* Operadores y delimitadores especiales */
terminal OPEN_BLOCK, CLOSE_BLOCK;        // ¡ !
terminal OPEN_PAREN, CLOSE_PAREN;        // ¿ ?
terminal OPEN_BRACKET, CLOSE_BRACKET;    // [ ]
terminal INCREMENT, DECREMENT;            // ++ --
terminal PLUS, MINUS, MULT, DIV, INT_DIV, MOD, POWER;
terminal LTEQ, GTEQ, EQEQ, NEQ, LT, GT;
terminal AND, OR, NOT;                    // @ ~ Σ
terminal ASSIGN, ARROW;                   // = ->
terminal COMMA, SEMICOLON;

/* Literales que cargan un valor específico (value) */
terminal Integer INT_LITERAL;
terminal Float   FLOAT_LITERAL;
terminal String  STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal String ID;

/* Terminal especial para reportar errores léxicos al Main */
terminal ERROR;

non terminal programa;
non terminal declaracionesGlobales;
non terminal declaracionGlobal;
non terminal navidad;
non terminal declaracionesFunciones;
non terminal declaracionFuncion;
non terminal parametros;
non terminal listaParametros;
non terminal parametro;
non terminal tipo;
non terminal array;
non terminal sentencias;
non terminal sentencia;
non terminal declaracionLocal;
non terminal inicializacionArray;
non terminal filaArray;
non terminal listaValores;
non terminal asignacion;
non terminal accesoArray;
non terminal expresion;
non terminal disyuncion;
non terminal conjuncion;
non terminal negacion;
non terminal comparacion;
non terminal aditiva;
non terminal multiplicativa;
non terminal potencia;
non terminal unaria;
non terminal primaria;
non terminal opRel;
non terminal opUnario;
non terminal literal;
non terminal literalBooleano;
non terminal estructuraControl;
non terminal decideOf;
non terminal casosDecide;
non terminal caso;
non terminal casoElseOpt;
non terminal loop;
non terminal forLoop;
non terminal inicializacionFor;
non terminal actualizacionFor;
non terminal sentenciaIO;
non terminal argumentos;
non terminal listaExpresiones;

/* ========== PRECEDENCIA ========== */

precedence left OR;
precedence left AND;
precedence right NOT;
precedence left EQEQ, NEQ, LT, LTEQ, GT, GTEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, INT_DIV, MOD;
precedence right POWER;
precedence right INCREMENT, DECREMENT;
precedence left ENDL;

/* ========== SÍMBOLO INICIAL ========== */

start with programa;

/* ========== GRAMÁTICA CON CONSTRUCCIÓN DE ÁRBOL ========== */

programa ::= declaracionesGlobales:dg navidad:n declaracionesFunciones:df
    {:
        Nodo result = new Nodo("programa");
        if (dg != null) result.addHijo((Nodo)dg);
        result.addHijo((Nodo)n);
        if (df != null) result.addHijo((Nodo)df);
        
        parser.arbolSintactico = result;
        System.out.println("✓ Programa sintácticamente correcto");
        RESULT = (Nodo)result;
    :}
    ;

declaracionesGlobales ::= /* empty */
    {: RESULT = (Nodo)null; :}
    | declaracionesGlobales:dgs declaracionGlobal:dg
    {:
        Nodo result;
        if (dgs == null) {
            result = new Nodo("declaracionesGlobales");
            result.addHijo((Nodo)dg);
        } else {
            result = (Nodo)dgs;
            result.addHijo((Nodo)dg);
        }
        RESULT = result;
    :}
    ;

declaracionGlobal ::= WORLD ID:id tipo:t ENDL
    {:
        Nodo result = new Nodo("declaracionGlobal");
        result.addHijo(new Nodo("world", "WORLD"));
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)t);
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | WORLD ID:id tipo:t ASSIGN expresion:e ENDL
    {:
        Nodo result = new Nodo("declaracionGlobal");
        result.addHijo(new Nodo("world", "WORLD"));
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)t);
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | WORLD ID:id array:a ASSIGN OPEN_BLOCK inicializacionArray:ia CLOSE_BLOCK ENDL
    {:
        Nodo result = new Nodo("declaracionGlobal");
        result.addHijo(new Nodo("world", "WORLD"));
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)a);
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo(new Nodo("¡", "OPEN_BLOCK"));
        result.addHijo((Nodo)ia);
        result.addHijo(new Nodo("!", "CLOSE_BLOCK"));
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    ;

navidad ::= NAVIDAD COAL OPEN_BLOCK sentencias:s CLOSE_BLOCK
    {:
        Nodo result = new Nodo("navidad");
        result.addHijo(new Nodo("navidad", "NAVIDAD"));
        result.addHijo(new Nodo("coal", "COAL"));
        result.addHijo(new Nodo("¡", "OPEN_BLOCK"));
        if (s != null) result.addHijo((Nodo)s);
        result.addHijo(new Nodo("!", "CLOSE_BLOCK"));
        RESULT = (Nodo)result;
    :}
    ;

declaracionesFunciones ::= /* empty */
    {: RESULT = (Nodo)null; :}
    | declaracionesFunciones:dfs declaracionFuncion:df
    {:
        Nodo result;
        if (dfs == null) {
            result = new Nodo("declaracionesFunciones");
            result.addHijo((Nodo)df);
        } else {
            result = (Nodo)dfs;
            result.addHijo((Nodo)df);
        }
        RESULT = result;
    :}
    ;

declaracionFuncion ::= GIFT ID:id OPEN_PAREN parametros:p CLOSE_PAREN tipo:t OPEN_BLOCK sentencias:s CLOSE_BLOCK
    {:
        Nodo result = new Nodo("declaracionFuncion");
        result.addHijo(new Nodo("gift", "GIFT"));
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo(new Nodo("¿", "OPEN_PAREN"));
        if (p != null) result.addHijo((Nodo)p);
        result.addHijo(new Nodo("?", "CLOSE_PAREN"));
        result.addHijo((Nodo)t);
        result.addHijo(new Nodo("¡", "OPEN_BLOCK"));
        if (s != null) result.addHijo((Nodo)s);
        result.addHijo(new Nodo("!", "CLOSE_BLOCK"));
        RESULT = (Nodo)result;
    :}
    ;

parametros ::= listaParametros:lp
    {: RESULT = (Nodo)lp; :}
    | /* empty */
    {: RESULT = (Nodo)null; :}
    ;

listaParametros ::= parametro:p
    {:
        Nodo result = new Nodo("listaParametros");
        result.addHijo((Nodo)p);
        RESULT = (Nodo)result;
    :}
    | listaParametros:lp COMMA parametro:p
    {:
        Nodo lpNodo = (Nodo)lp;
        lpNodo.addHijo(new Nodo(",", "COMMA"));
        lpNodo.addHijo((Nodo)p);
        RESULT = lpNodo;
    :}
    ;

parametro ::= ID:id tipo:t
    {:
        Nodo result = new Nodo("parametro");
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)t);
        RESULT = (Nodo)result;
    :}
    | ID:id array:a
    {:
        Nodo result = new Nodo("parametro");
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)a);
        RESULT = (Nodo)result;
    :}
    ;

tipo ::= INT
    {:
        Nodo result = new Nodo("tipo");
        result.addHijo(new Nodo("int", "INT"));
        RESULT = (Nodo)result;
    :}
    | FLOAT
    {:
        Nodo result = new Nodo("tipo");
        result.addHijo(new Nodo("float", "FLOAT"));
        RESULT = (Nodo)result;
    :}
    | BOOL
    {:
        Nodo result = new Nodo("tipo");
        result.addHijo(new Nodo("bool", "BOOL"));
        RESULT = (Nodo)result;
    :}
    | CHAR
    {:
        Nodo result = new Nodo("tipo");
        result.addHijo(new Nodo("char", "CHAR"));
        RESULT = (Nodo)result;
    :}
    | STRING
    {:
        Nodo result = new Nodo("tipo");
        result.addHijo(new Nodo("string", "STRING"));
        RESULT = (Nodo)result;
    :}
    ;

array ::= INT OPEN_BRACKET expresion:e1 COMMA expresion:e2 CLOSE_BRACKET
    {:
        Nodo result = new Nodo("array");
        result.addHijo(new Nodo("int", "INT"));
        result.addHijo(new Nodo("[", "OPEN_BRACKET"));
        result.addHijo((Nodo)e1);
        result.addHijo(new Nodo(",", "COMMA"));
        result.addHijo((Nodo)e2);
        result.addHijo(new Nodo("]", "CLOSE_BRACKET"));
        RESULT = (Nodo)result;
    :}
    | CHAR OPEN_BRACKET expresion:e1 COMMA expresion:e2 CLOSE_BRACKET
    {:
        Nodo result = new Nodo("array");
        result.addHijo(new Nodo("char", "CHAR"));
        result.addHijo(new Nodo("[", "OPEN_BRACKET"));
        result.addHijo((Nodo)e1);
        result.addHijo(new Nodo(",", "COMMA"));
        result.addHijo((Nodo)e2);
        result.addHijo(new Nodo("]", "CLOSE_BRACKET"));
        RESULT = (Nodo)result;
    :}
    ;

sentencias ::= /* empty */
    {: RESULT = (Nodo)null; :}
    | sentencias:ss sentencia:s
    {:
        if (ss == null) {
            Nodo result = new Nodo("sentencias");
            result.addHijo((Nodo)s);
            RESULT = result;
        } else {
            Nodo ssNodo = (Nodo)ss;
            ssNodo.addHijo((Nodo)s);
            RESULT = ssNodo;
        }
    :}
    ;

sentencia ::= declaracionLocal:dl
    {: RESULT = (Nodo)dl; :}
    | asignacion:a
    {: RESULT = (Nodo)a; :}
    | expresion:e ENDL
    {:
        Nodo result = new Nodo("sentencia");
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | estructuraControl:ec
    {: RESULT = (Nodo)ec; :}
    | ID:id OPEN_PAREN argumentos:a CLOSE_PAREN ENDL
    {:
        Nodo result = new Nodo("sentencia");
        result.addHijo(new Nodo(id, "ID"));
        result.addHijo(new Nodo("¿", "OPEN_PAREN"));
        if (a != null) result.addHijo((Nodo)a);
        result.addHijo(new Nodo("?", "CLOSE_PAREN"));
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | sentenciaIO:sio
    {: RESULT = (Nodo)sio; :}
    | RETURN expresion:e ENDL
    {:
        Nodo result = new Nodo("sentencia");
        result.addHijo(new Nodo("return", "RETURN"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | BREAK ENDL
    {:
        Nodo result = new Nodo("sentencia");
        result.addHijo(new Nodo("break", "BREAK"));
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    ;

declaracionLocal ::= LOCAL ID:id tipo:t ENDL
    {:
        Nodo result = new Nodo("declaracionLocal");
        result.addHijo(new Nodo("local", "LOCAL"));
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)t);
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | LOCAL ID:id tipo:t ASSIGN expresion:e ENDL
    {:
        Nodo result = new Nodo("declaracionLocal");
        result.addHijo(new Nodo("local", "LOCAL"));
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)t);
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | LOCAL ID:id array:a ASSIGN OPEN_BLOCK inicializacionArray:ia CLOSE_BLOCK ENDL
    {:
        Nodo result = new Nodo("declaracionLocal");
        result.addHijo(new Nodo("local", "LOCAL"));
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)a);
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo(new Nodo("¡", "OPEN_BLOCK"));
        result.addHijo((Nodo)ia);
        result.addHijo(new Nodo("!", "CLOSE_BLOCK"));
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    ;

inicializacionArray ::= filaArray:fa
    {:
        Nodo result = new Nodo("inicializacionArray");
        result.addHijo((Nodo)fa);
        RESULT = (Nodo)result;
    :}
    | inicializacionArray:ia COMMA filaArray:fa
    {:
        Nodo iaNodo = (Nodo)ia;
        iaNodo.addHijo(new Nodo(",", "COMMA"));
        iaNodo.addHijo((Nodo)fa);
        RESULT = iaNodo;
    :}
    ;

filaArray ::= OPEN_BLOCK listaValores:lv CLOSE_BLOCK
    {:
        Nodo result = new Nodo("filaArray");
        result.addHijo(new Nodo("¡", "OPEN_BLOCK"));
        result.addHijo((Nodo)lv);
        result.addHijo(new Nodo("!", "CLOSE_BLOCK"));
        RESULT = (Nodo)result;
    :}
    ;

listaValores ::= expresion:e
    {:
        Nodo result = new Nodo("listaValores");
        result.addHijo((Nodo)e);
        RESULT = (Nodo)result;
    :}
    | listaValores:lv COMMA expresion:e
    {:
        Nodo lvNodo = (Nodo)lv;
        lvNodo.addHijo(new Nodo(",", "COMMA"));
        lvNodo.addHijo((Nodo)e);
        RESULT = lvNodo;
    :}
    ;

asignacion ::= ID:id ASSIGN expresion:e ENDL
    {:
        Nodo result = new Nodo("asignacion");
        result.addHijo(new Nodo(id, "ID"));
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | accesoArray:aa ASSIGN expresion:e ENDL
    {:
        Nodo result = new Nodo("asignacion");
        result.addHijo((Nodo)aa);
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    ;

accesoArray ::= ID:id OPEN_BRACKET expresion:e1 COMMA expresion:e2 CLOSE_BRACKET
    {:
        Nodo result = new Nodo("accesoArray");
        result.addHijo(new Nodo(id, "ID"));
        result.addHijo(new Nodo("[", "OPEN_BRACKET"));
        result.addHijo((Nodo)e1);
        result.addHijo(new Nodo(",", "COMMA"));
        result.addHijo((Nodo)e2);
        result.addHijo(new Nodo("]", "CLOSE_BRACKET"));
        RESULT = (Nodo)result;
    :}
    ;

expresion ::= disyuncion:d
    {: RESULT = (Nodo)d; :}
    ;

disyuncion ::= disyuncion:d OR conjuncion:c
    {:
        Nodo result = new Nodo("disyuncion");
        result.addHijo((Nodo)d);
        result.addHijo(new Nodo("~", "OR"));
        result.addHijo((Nodo)c);
        RESULT = (Nodo)result;
    :}
    | conjuncion:c
    {: RESULT = (Nodo)c; :}
    ;

conjuncion ::= conjuncion:c AND negacion:n
    {:
        Nodo result = new Nodo("conjuncion");
        result.addHijo((Nodo)c);
        result.addHijo(new Nodo("@", "AND"));
        result.addHijo((Nodo)n);
        RESULT = (Nodo)result;
    :}
    | negacion:n
    {: RESULT = (Nodo)n; :}
    ;

negacion ::= NOT negacion:n
    {:
        Nodo result = new Nodo("negacion");
        result.addHijo(new Nodo("Σ", "NOT"));
        result.addHijo((Nodo)n);
        RESULT = (Nodo)result;
    :}
    | comparacion:c
    {: RESULT = (Nodo)c; :}
    ;

comparacion ::= aditiva:a1 opRel:op aditiva:a2
    {:
        Nodo result = new Nodo("comparacion");
        result.addHijo((Nodo)a1);
        result.addHijo((Nodo)op);
        result.addHijo((Nodo)a2);
        RESULT = (Nodo)result;
    :}
    | aditiva:a
    {: RESULT = (Nodo)a; :}
    ;

opRel ::= LT
    {: RESULT = new Nodo("<", "LT"); :}
    | LTEQ
    {: RESULT = new Nodo("<=", "LTEQ"); :}
    | GT
    {: RESULT = new Nodo(">", "GT"); :}
    | GTEQ
    {: RESULT = new Nodo(">=", "GTEQ"); :}
    | EQEQ
    {: RESULT = new Nodo("==", "EQEQ"); :}
    | NEQ
    {: RESULT = new Nodo("Σ=", "NEQ"); :}
    ;

aditiva ::= aditiva:a PLUS multiplicativa:m
    {:
        Nodo result = new Nodo("aditiva");
        result.addHijo((Nodo)a);
        result.addHijo(new Nodo("+", "PLUS"));
        result.addHijo((Nodo)m);
        RESULT = (Nodo)result;
    :}
    | aditiva:a MINUS multiplicativa:m
    {:
        Nodo result = new Nodo("aditiva");
        result.addHijo((Nodo)a);
        result.addHijo(new Nodo("-", "MINUS"));
        result.addHijo((Nodo)m);
        RESULT = (Nodo)result;
    :}
    | multiplicativa:m
    {: RESULT = (Nodo)m; :}
    ;

multiplicativa ::= multiplicativa:m MULT potencia:p
    {:
        Nodo result = new Nodo("multiplicativa");
        result.addHijo((Nodo)m);
        result.addHijo(new Nodo("*", "MULT"));
        result.addHijo((Nodo)p);
        RESULT = (Nodo)result;
    :}
    | multiplicativa:m DIV potencia:p
    {:
        Nodo result = new Nodo("multiplicativa");
        result.addHijo((Nodo)m);
        result.addHijo(new Nodo("/", "DIV"));
        result.addHijo((Nodo)p);
        RESULT = (Nodo)result;
    :}
    | multiplicativa:m INT_DIV potencia:p
    {:
        Nodo result = new Nodo("multiplicativa");
        result.addHijo((Nodo)m);
        result.addHijo(new Nodo("//", "INT_DIV"));
        result.addHijo((Nodo)p);
        RESULT = (Nodo)result;
    :}
    | multiplicativa:m MOD potencia:p
    {:
        Nodo result = new Nodo("multiplicativa");
        result.addHijo((Nodo)m);
        result.addHijo(new Nodo("%", "MOD"));
        result.addHijo((Nodo)p);
        RESULT = (Nodo)result;
    :}
    | potencia:p
    {: RESULT = (Nodo)p; :}
    ;

potencia ::= unaria:u POWER potencia:p
    {:
        Nodo result = new Nodo("potencia");
        result.addHijo((Nodo)u);
        result.addHijo(new Nodo("^", "POWER"));
        result.addHijo((Nodo)p);
        RESULT = (Nodo)result;
    :}
    | unaria:u
    {: RESULT = (Nodo)u; :}
    ;

unaria ::= MINUS unaria:u
    {:
        Nodo result = new Nodo("unaria");
        result.addHijo(new Nodo("-", "MINUS"));
        result.addHijo((Nodo)u);
        RESULT = (Nodo)result;
    :}
    | opUnario:op ID:id
    {:
        Nodo result = new Nodo("unaria");
        result.addHijo((Nodo)op);
        result.addHijo(new Nodo(id, "ID"));
        RESULT = (Nodo)result;
    :}
    | primaria:p
    {: RESULT = (Nodo)p; :}
    ;

opUnario ::= INCREMENT
    {: RESULT = new Nodo("++", "INCREMENT"); :}
    | DECREMENT
    {: RESULT = new Nodo("--", "DECREMENT"); :}
    ;

primaria ::= OPEN_PAREN expresion:e CLOSE_PAREN
    {:
        Nodo result = new Nodo("primaria");
        result.addHijo(new Nodo("¿", "OPEN_PAREN"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("?", "CLOSE_PAREN"));
        RESULT = (Nodo)result;
    :}
    | ID:id OPEN_PAREN argumentos:a CLOSE_PAREN
    {:
        Nodo result = new Nodo("primaria");
        result.addHijo(new Nodo(id, "ID"));
        result.addHijo(new Nodo("¿", "OPEN_PAREN"));
        if (a != null) result.addHijo((Nodo)a);
        result.addHijo(new Nodo("?", "CLOSE_PAREN"));
        RESULT = (Nodo)result;
    :}
    | ID:id
    {:
        Nodo result = new Nodo("primaria");
        result.addHijo(new Nodo(id, "ID"));
        RESULT = (Nodo)result;
    :}
    | literal:l
    {: RESULT = (Nodo)l; :}
    | accesoArray:aa
    {: RESULT = (Nodo)aa; :}
    ;

literal ::= INT_LITERAL:val
    {:
        Nodo result = new Nodo("literal");
        result.addHijo(new Nodo(val.toString(), "INT_LITERAL"));
        RESULT = (Nodo)result;
    :}
    | FLOAT_LITERAL:val
    {:
        Nodo result = new Nodo("literal");
        result.addHijo(new Nodo(val.toString(), "FLOAT_LITERAL"));
        RESULT = (Nodo)result;
    :}
    | literalBooleano:lb
    {: RESULT = (Nodo)lb; :}
    | CHAR_LITERAL:val
    {:
        Nodo result = new Nodo("literal");
        result.addHijo(new Nodo("'" + val + "'", "CHAR_LITERAL"));
        RESULT = (Nodo)result;
    :}
    | STRING_LITERAL:val
    {:
        Nodo result = new Nodo("literal");
        result.addHijo(new Nodo(val, "STRING_LITERAL"));
        RESULT = (Nodo)result;
    :}
    ;

literalBooleano ::= TRUE
    {:
        Nodo result = new Nodo("literalBooleano");
        result.addHijo(new Nodo("true", "TRUE"));
        RESULT = (Nodo)result;
    :}
    | FALSE
    {:
        Nodo result = new Nodo("literalBooleano");
        result.addHijo(new Nodo("false", "FALSE"));
        RESULT = (Nodo)result;
    :}
    ;

estructuraControl ::= decideOf:d
    {: RESULT = (Nodo)d; :}
    | loop:l
    {: RESULT = (Nodo)l; :}
    | forLoop:f
    {: RESULT = (Nodo)f; :}
    ;

decideOf ::= DECIDE OF casosDecide:cd casoElseOpt:ce END DECIDE ENDL
    {:
        Nodo result = new Nodo("decideOf");
        result.addHijo(new Nodo("decide", "DECIDE"));
        result.addHijo(new Nodo("of", "OF"));
        result.addHijo((Nodo)cd);
        if (ce != null) result.addHijo((Nodo)ce);
        result.addHijo(new Nodo("end", "END"));
        result.addHijo(new Nodo("decide", "DECIDE"));
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    ;

casosDecide ::= caso:c
    {:
        Nodo result = new Nodo("casosDecide");
        result.addHijo((Nodo)c);
        RESULT = (Nodo)result;
    :}
    | casosDecide:cd caso:c
    {:
        Nodo cdNodo = (Nodo)cd;
        cdNodo.addHijo((Nodo)c);
        RESULT = cdNodo;
    :}
    ;

caso ::= expresion:e ARROW OPEN_BLOCK sentencias:s CLOSE_BLOCK
    {:
        Nodo result = new Nodo("caso");
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("->", "ARROW"));
        result.addHijo(new Nodo("¡", "OPEN_BLOCK"));
        if (s != null) result.addHijo((Nodo)s);
        result.addHijo(new Nodo("!", "CLOSE_BLOCK"));
        RESULT = (Nodo)result;
    :}
    ;

casoElseOpt ::= ELSE ARROW OPEN_BLOCK sentencias:s CLOSE_BLOCK
    {:
        Nodo result = new Nodo("casoElseOpt");
        result.addHijo(new Nodo("else", "ELSE"));
        result.addHijo(new Nodo("->", "ARROW"));
        result.addHijo(new Nodo("¡", "OPEN_BLOCK"));
        if (s != null) result.addHijo((Nodo)s);
        result.addHijo(new Nodo("!", "CLOSE_BLOCK"));
        RESULT = (Nodo)result;
    :}
    | /* empty */
    {: RESULT = (Nodo)null; :}
    ;

loop ::= LOOP sentencias:s1 EXIT WHEN expresion:e ENDL sentencias:s2 END LOOP ENDL
    {:
        Nodo result = new Nodo("loop");
        result.addHijo(new Nodo("loop", "LOOP"));
        if (s1 != null) result.addHijo((Nodo)s1);
        result.addHijo(new Nodo("exit", "EXIT"));
        result.addHijo(new Nodo("when", "WHEN"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("endl", "ENDL"));
        if (s2 != null) result.addHijo((Nodo)s2);
        result.addHijo(new Nodo("end", "END"));
        result.addHijo(new Nodo("loop", "LOOP"));
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    ;

forLoop ::= FOR OPEN_PAREN inicializacionFor:i SEMICOLON expresion:e SEMICOLON actualizacionFor:a CLOSE_PAREN OPEN_BLOCK sentencias:s CLOSE_BLOCK
    {:
        Nodo result = new Nodo("forLoop");
        result.addHijo(new Nodo("for", "FOR"));
        result.addHijo(new Nodo("¿", "OPEN_PAREN"));
        if (i != null) result.addHijo((Nodo)i);
        result.addHijo(new Nodo(";", "SEMICOLON"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo(";", "SEMICOLON"));
        if (a != null) result.addHijo((Nodo)a);
        result.addHijo(new Nodo("?", "CLOSE_PAREN"));
        result.addHijo(new Nodo("¡", "OPEN_BLOCK"));
        if (s != null) result.addHijo((Nodo)s);
        result.addHijo(new Nodo("!", "CLOSE_BLOCK"));
        RESULT = (Nodo)result;
    :}
    ;

inicializacionFor ::= LOCAL ID:id tipo:t ASSIGN expresion:e
    {:
        Nodo result = new Nodo("inicializacionFor");
        result.addHijo(new Nodo("local", "LOCAL"));
        
        Nodo nodoID = new Nodo(id, "ID");
        nodoID.setLinea(idleft);
        result.addHijo(nodoID);
        
        result.addHijo((Nodo)t);
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo((Nodo)e);
        RESULT = (Nodo)result;
    :}
    | ID:id ASSIGN expresion:e
    {:
        Nodo result = new Nodo("inicializacionFor");
        result.addHijo(new Nodo(id, "ID"));
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo((Nodo)e);
        RESULT = (Nodo)result;
    :}
    | /* empty */
    {: RESULT = (Nodo)null; :}
    ;


actualizacionFor ::= ID:id ASSIGN expresion:e
    {:
        Nodo result = new Nodo("actualizacionFor");
        result.addHijo(new Nodo(id, "ID"));
        result.addHijo(new Nodo("=", "ASSIGN"));
        result.addHijo((Nodo)e);
        RESULT = (Nodo)result;
    :}
    | opUnario:op ID:id
    {:
        Nodo result = new Nodo("actualizacionFor");
        result.addHijo((Nodo)op);
        result.addHijo(new Nodo(id, "ID"));
        RESULT = (Nodo)result;
    :}
    | /* empty */
    {: RESULT = (Nodo)null; :}
    ;

sentenciaIO ::= SHOW OPEN_PAREN expresion:e CLOSE_PAREN ENDL
    {:
        Nodo result = new Nodo("sentenciaIO");
        result.addHijo(new Nodo("show", "SHOW"));
        result.addHijo(new Nodo("¿", "OPEN_PAREN"));
        result.addHijo((Nodo)e);
        result.addHijo(new Nodo("?", "CLOSE_PAREN"));
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    | GET OPEN_PAREN ID:id CLOSE_PAREN ENDL
    {:
        Nodo result = new Nodo("sentenciaIO");
        result.addHijo(new Nodo("get", "GET"));
        result.addHijo(new Nodo("¿", "OPEN_PAREN"));
        result.addHijo(new Nodo(id, "ID"));
        result.addHijo(new Nodo("?", "CLOSE_PAREN"));
        result.addHijo(new Nodo("endl", "ENDL"));
        RESULT = (Nodo)result;
    :}
    ;

argumentos ::= listaExpresiones:le
    {: RESULT = (Nodo)le; :}
    | /* empty */
    {: RESULT = (Nodo)null; :}
    ;

listaExpresiones ::= expresion:e
    {:
        Nodo result = new Nodo("listaExpresiones");
        result.addHijo((Nodo)e);
        RESULT = (Nodo)result;
    :}
    | listaExpresiones:le COMMA expresion:e
    {:
        Nodo leNodo = (Nodo)le;
        leNodo.addHijo(new Nodo(",", "COMMA"));
        leNodo.addHijo((Nodo)e);
        RESULT = leNodo;
    :}
    ;
